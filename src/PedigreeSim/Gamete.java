/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package PedigreeSim;

/**
 * a Gamete is a Genotype with a ploidy half of popdata.ploidy,
 * which is able to do fertilization with another Gamete
 * @author Roeland Voorrips
 */
public class Gamete extends Genotype {

    /**
     * parconfig stores the parental meiotic configurations that produced
     * this Gamete.
     * The index is for the chromosome
     */
    ChromConfig[] parconfig;

    /**
     * This constructor directly specifies the haplostruct.
     * In practice we use the other constructor which takes a list of
     * all haplostructs generated by a meiosis and selects the specified ones.
     * @param haplostruct
     * @param popdata
     * @throws Exception
     */
    public Gamete(HaploStruct[][] haplostruct, PopulationData popdata)
            throws Exception {
        super(popdata);
        setHaploStruct(haplostruct);
    }

    /**This constructor allows to supply a list "allGametes" as HaploStruct[][],
     * which is the list of HaploStructs in all four gametes
     * resulting from one meiosis. The first index points to the different
     * chromosomes, the length of the second index should be 2*popdata.ploidy.
     * From this source the items (second index) indicated by index are selected
     * for the current Gamete; the length of index would therefore be
     * popdata.ploidy/2
     * @param allGametes The list of HaploStructs in all four gametes
     * resulting from one meiosis. The first index points to the different
     * chromosomes, the length of the second index should be 4*(popdata.ploidy/2).
     * @param index An int[] with length equal to ploidy; this indicates the
     * items to select from source (values of index must be in the range of
     * the second index of source)
     * @param popdata
     * @throws Exception
     */
    public Gamete(HaploStruct[][] allGametes, int[] index,
            PopulationData popdata) throws Exception {
        super(popdata);
        super.checkHaploStruct(popdata.ploidy*2, allGametes);
        if (index.length!=popdata.ploidy/2) {
            throw new Exception("Gamete constructor: index length invalid");
        }
        haplostruct = new HaploStruct[popdata.chromCount()][];
        for (int c=0; c<popdata.chromCount(); c++) {
            haplostruct[c] = new HaploStruct[popdata.ploidy/2];
        }
        for (int p=0; p<popdata.ploidy/2; p++) {
            if (index[p]<0 || index[p]>=allGametes[0].length) {
                throw new Exception("Gamete constructor: index values invalid");
            }
            for (int c=0; c<popdata.chromCount(); c++) {
                haplostruct[c][p] = allGametes[c][index[p]];
            }
        }

    }

    private void setHaploStruct(HaploStruct[][] haplostruct) throws Exception {
        if (checkHaploStruct(popdata.ploidy/2, haplostruct)) {
            this.haplostruct = haplostruct;
        } else {
            throw new Exception("Gamete setHaploStruct: invalid haplostruct");
        }
    }

    /**
     * fertilization creates the genotype (haplostruct) of a new individual
     * (zygote) from the fusion of two Gametes.
     * In the offspring the haplostruct from this gamete are added first
     * and those from otherGamete last; the order of the haplostruct are
     * not changed within or between the gametes.
     * Also the configurations of the two parental meioses are stored in
     * zygote.
     * @param otherGamete the gamete to join with
     * @param zygote the (already initialized) Individual produced by this
     *     fertilization
     * @throws Exception
     */
    public void fertilization(Gamete otherGamete, Individual zygote)
            throws Exception {
        if (otherGamete==null ||
                !otherGamete.getPopdata().equals(popdata)) {
            throw new Exception("Gamete invalid in fertilization");
        }
        if (zygote==null ||
                !zygote.getPopdata().equals(popdata))
            throw new Exception("zygote invalid in fertilization");
        //zygote.haplostruct = new HaploStruct[popdata.chromCount()][popdata.ploidy];
        HaploStruct[][] zygoteHS = new HaploStruct[popdata.chromCount()][popdata.ploidy];
        for (int p=0; p<popdata.ploidy/2; p++) {
            for (int c=0; c<popdata.chromCount(); c++) {
                zygoteHS[c][p] = this.getHaploStruct(c, p);
                zygoteHS[c][popdata.ploidy/2+p] = otherGamete.getHaploStruct(c, p);
            }
        }
        zygote.setHaploStruct(zygoteHS);
        zygote.parconfig = new ChromConfig[2][];
        zygote.parconfig[0] = this.parconfig;
        zygote.parconfig[1] = otherGamete.parconfig;
    }


}
